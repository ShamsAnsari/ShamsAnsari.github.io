<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">

    <title>Algorithms</title>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
    <h1 id="title">Algorithms</h1>
    <div class="table-contents">
        <h3>Table of contents</h3>
        <ul>
            <li><a href="#insertion-sort">Insertion sort</a></li>
            <li><a href="#selection-sort">Selection sort </a></li>
            <li><a href="#merge-sort">Merge sort </a></li>
            <li><a href="#heapsort">Heapsort</a></li>
            <li><a href="#quicksort">Quicksort</a></li>
            <li><a href="#bubble-sort">Bubble sort</a></li>
        </ul>
    </div>
    <!-- Insertion sort -->
    <div class="insertion-sort">
        <h3 id="insertion-sort">Insertion Sort</h3>
        <p>
            Insertion sort is a simple sorting algorithm that is relatively efficient
            for small lists and mostly sorted lists, and is often used as part of more
            sophisticated algorithms. It works by taking elements from the list one by
            one and inserting them in their correct position into a new sorted list
            similar to how we put money in our wallet. In arrays, the new list and
            the remaining elements can share the array's space, but insertion is
            expensive, requiring shifting all following elements over by one.
            Shellsort is a variant of insertion sort that is more efficient for larger
            lists.
        </p>
        <pre>def insertionSort(arr):

        <span># Traverse through 1 to len(arr)</span>
    for i in range(1, len(arr)):

        key = arr[i]
        <span>
        # Move elements of arr[0..i-1], that are
        # greater than key, to one position ahead
        # of their current position</span>
        j = i-1
        while j &gt;= 0 and key &lt; arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key</pre>
    </div>
    <!--Selection sort-->
    <div class="selection-sort">
        <h3 id="selection-sort">Selection Sort</h3>
        <p>
            Selection sort is an in-place comparison sort. It has O(n2) complexity,
            making it inefficient on large lists, and generally performs worse than the
            similar insertion sort. Selection sort is noted for its simplicity, and also
            has performance advantages over more complicated algorithms in certain situations.
            <br>The algorithm finds the minimum value, swaps it with the value in the
            first position, and repeats these steps for the remainder of the list.
            It does no more than n swaps, and thus is useful where swapping is very expensive.
        </p>
        <pre>def selection_sort(arr-&gt;[]):
        <span># Traverse through all array elements</span>
    for i in range(len(arr)):

        <span>    # Find the minimum element in remaining
        # unsorted array</span>
        min_idx = i
        for j in range(i+1, len(arr)):
            if arr[min_idx] &gt; arr[j]:
                min_idx = j

        <span># Swap the found minimum element with
        # the first element</span>
        arr[i], arr[min_idx] = arr[min_idx], arr[i]</pre>
    </div>
    <!-- Merge sort -->
    <div class="merge-sort">
        <h3 id="merge-sort">Merge Sort</h3>
        <p>
            Merge sort takes advantage of the ease of merging already sorted lists into
            a new sorted list. It starts by comparing every two elements (i.e., 1 with
            2, then 3 with 4...) and swapping them if the first should come after the
            second. It then merges each of the resulting lists of two into lists of
            four, then merges those lists of four, and so on; until at last two lists
            are merged into the final sorted list. Of the algorithms described here,
            this is the first that scales well to very large lists, because its
            worst-case running time is O(n log n). It is also easily applied to lists,
            not only arrays, as it only requires sequential access, not random access.
            However, it has additional O(n) space complexity, and involves a large
            number of copies in simple implementations.
            <br>Merge sort has seen a relatively recent surge in popularity for practical
            implementations, due to its use in the sophisticated algorithm Timsort,
            which is used for the standard sort routine in the programming languages
            Python and Java (as of JDK7). Merge sort itself is the standard
            routine in Perl, among others, and has been used in Java at least
            since 2000 in JDK1.3.
        </p>
        <pre>def mergeSort(arr):
    if len(arr) >1:
        mid = len(arr)//2 <span>#Finding the mid of the array</span>
        L = arr[:mid] <span># Dividing the array elements</span>
        R = arr[mid:] <span># into 2 halves</span>

        mergeSort(L) <span># Sorting the first half</span>
        mergeSort(R) <span># Sorting the second half</span>

        i = j = k = 0

        <span># Copy data to temp arrays L[] and R[]</span>
        while i &lt len(L) and j &lt len(R):
            if L[i] &lt  R[j]:
                arr[k] = L[i]
                i+=1
            else:
                arr[k] = R[j]
                j+=1
            k+=1

        <span># Checking if any element was left</span>
        while i &lt len(L):
            arr[k] = L[i]
            i+=1
            k+=1

        while j &lt len(R):
            arr[k] = R[j]
            j+=1
            k+=1</pre>
    </div>
    <!-- Heapsort>=-->
    <div class="heap-sort">
        <h3 id="heapsort">Heapsort</h3>
        <p>
            Heapsort is a much more efficient version of selection sort. It also works
            by determining the largest (or smallest) element of the list, placing that
            at the end (or beginning) of the list, then continuing with the rest of the list, but
            accomplishes this task efficiently by using a data structure called a heap,
            a special type of binary tree.[29] Once the data list has been made into a
            heap, the root node is guaranteed to be the largest (or smallest) element. When it is removed
            and placed at the end of the list, the heap is rearranged so the largest
            element remaining moves to the root. Using the heap, finding the next largest
            element takes O(log n) time, instead of O(n) for a linear scan as in simple selection sort.
            This allows Heapsort to run in O(n log n) time, and this is also the worst case complexity.
        </p>
        <pre><span># To heapify subtree rooted at index i.
# n is size of heap</span>
def heapify(arr, n, i):
    largest = i   <span># Initialize largest as root</span>
    l = 2 * i + 1    <span># left = 2*i + 1</span>
    r = 2 * i + 2    <span># right = 2*i + 2</span>

        <span># See if left child of root exists and is
    # greater than root</span>
    if l &lt; n and arr[i] &lt; arr[l]:
        largest = l
        <span>
    # See if right child of root exists and is
    # greater than root</span>
    if r &lt; n and arr[largest] &lt; arr[r]:
        largest = r
        <span>
    # Change root, if needed</span>
    if largest != i:
        arr[i],arr[largest] = arr[largest],arr[i] <span># swap</span>
        <span>
        # Heapify the root.</span>
        heapify(arr, n, largest)

<span># The main function to sort an array of given size</span>
def heapSort(arr):
    n = len(arr)
        <span>
    # Build a maxheap.</span>
    for i in range(n/2 - 1, -1, -1):
        heapify(arr, n, i)
        <span>
    # One by one extract elements</span>
    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i] <span># swap</span>
        heapify(arr, i, 0)</pre>
    </div>
    <!-- Quicksort -->
    <div class="quicksort">
        <h3 id="quicksort">Quicksort</h3>
        <p>
            Quicksort is a divide and conquer algorithm which relies on a partition operation: to partition an array, an element called a pivot is selected.[30][31] All elements smaller than the pivot are moved before it and all greater elements are moved
            after it. This can be done efficiently in linear time and in-place. The lesser and greater sublists are then recursively sorted. This yields average time complexity of O(n log n), with low overhead, and thus this is a popular algorithm. Efficient
            implementations of quicksort (with in-place partitioning) are typically unstable sorts and somewhat complex, but are among the fastest sorting algorithms in practice. Together with its modest O(log n) space usage, quicksort is one of the most
            popular sorting algorithms and is available in many standard programming libraries.
            <br>The important caveat about quicksort is that its worst-case performance is O(n2); while this is rare, in naive implementations (choosing the first or last element as pivot) this occurs for sorted data, which is a common case. The most complex
            issue in quicksort is thus choosing a good pivot element, as consistently poor choices of pivots can result in drastically slower O(n2) performance, but good choice of pivots yields O(n log n) performance, which is asymptotically optimal. For
            example, if at each step the median is chosen as the pivot then the algorithm works in O(n log n). Finding the median, such as by the median of medians selection algorithm is however an O(n) operation on unsorted lists and therefore exacts
            significant overhead with sorting. In practice choosing a random pivot almost certainly yields O(n log n) performance.
        </p>
    </div>
    <!-- Bubble sort -->
    <div class="bubble-sort">
        <h3 id="bubble-sort">Bubble Sort</h3>
        <p>
            Bubble sort is a simple sorting algorithm. The algorithm starts at the beginning of the data set. It compares the first two elements, and if the first is greater than the second, it swaps them. It continues doing this for each pair of adjacent
            elements to the end of the data set. It then starts again with the first two elements, repeating until no swaps have occurred on the last pass.[33] This algorithm's average time and worst-case performance is O(n2), so it is rarely used to sort
            large, unordered data sets. Bubble sort can be used to sort a small number of items (where its asymptotic inefficiency is not a high penalty). Bubble sort can also be used efficiently on a list of any length that is nearly sorted (that is, the
            elements are not significantly out of place). For example, if any number of elements are out of place by only one position (e.g. 0123546789 and 1032547698), bubble sort's exchange will get them in order on the first pass, the second pass will
            find all elements in order, so the sort will take only 2n time.
        </p>
    </div>
</body>
</html>
